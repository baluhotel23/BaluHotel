const { Room, RoomCheckIn, RoomBasics, Booking, Payment, BasicInventory, Service, BookingInventoryUsage } = require('../data');
const { Op } = require("sequelize");

// Obtener todas las habitaciones
const getAllRooms = async (req, res, next) => {
  try {
    console.log('üöÄ INICIANDO getAllRooms...');
    
    // ‚≠ê PASO 1: Verificar modelos disponibles
    console.log('üìã Modelos disponibles:', Object.keys(require('../data').sequelize.models));
    
    // ‚≠ê PASO 2: Verificar asociaciones de Room
    const { Room, Service, BasicInventory } = require('../data');
    console.log('üîç Asociaciones de Room:', Object.keys(Room.associations || {}));
    console.log('üîç Asociaciones de Service:', Object.keys(Service.associations || {}));
    console.log('üîç Asociaciones de BasicInventory:', Object.keys(BasicInventory.associations || {}));
    
    // ‚≠ê PASO 3: Probar query b√°sica primero
    console.log('üîÑ Intentando query b√°sica sin includes...');
    const basicRooms = await Room.findAll({
      attributes: ['roomNumber', 'type', 'description'],
      limit: 2
    });
    console.log('‚úÖ Query b√°sica exitosa:', basicRooms.length, 'habitaciones encontradas');
    
    // ‚≠ê PASO 4: Probar solo con Services
    console.log('üîÑ Probando solo con Services...');
    try {
      const roomsWithServices = await Room.findAll({
        include: [
          {
            model: Service,
            as: 'Services',
            attributes: ['serviceId', 'name'],
            through: { attributes: [] },
          }
        ],
        limit: 1
      });
      console.log('‚úÖ Query con Services exitosa:', roomsWithServices.length);
    } catch (serviceError) {
      console.log('‚ùå Error con Services:', serviceError.message);
    }
    
    // ‚≠ê PASO 5: Probar solo con BasicInventories
    console.log('üîÑ Probando solo con BasicInventories...');
    try {
      const roomsWithInventory = await Room.findAll({
        include: [
          {
            model: BasicInventory,
            as: 'BasicInventories',
            attributes: ['id', 'name'],
            through: { 
              attributes: ['quantity'],
              as: 'RoomBasics'
            },
          }
        ],
        limit: 1
      });
      console.log('‚úÖ Query con BasicInventories exitosa:', roomsWithInventory.length);
    } catch (inventoryError) {
      console.log('‚ùå Error con BasicInventories:', inventoryError.message);
    }
    
    // ‚≠ê PASO 6: Intentar query completa
    console.log('üîÑ Intentando query completa...');
    const rooms = await Room.findAll({
      include: [
        {
          model: Service,
          as: 'Services',
          attributes: ['serviceId', 'name', 'category', 'icon'],
          through: { attributes: [] },
        },
        {
          model: BasicInventory,
          as: 'BasicInventories',
          attributes: ['id', 'name', 'category', 'currentStock'],
          through: { 
            attributes: ['quantity', 'isRequired', 'priority'],
            as: 'RoomBasics'
          },
        },
      ],
      order: [['roomNumber', 'ASC']]
    });

    console.log('‚úÖ Query completa exitosa:', rooms.length, 'habitaciones con relaciones');

    res.json({
      error: false,
      data: rooms,
      message: 'Habitaciones obtenidas exitosamente'
    });
  } catch (error) {
    console.error('‚ùå Error en getAllRooms:', error.message);
    console.error('‚ùå Stack trace:', error.stack);
    console.error('‚ùå SQL Query (si existe):', error.sql);
    next(error);
  }
};

// Obtener tipos de habitaci√≥n
const getRoomTypes = async (req, res, next) => {
  try {
    const rooms = await Room.findAll({
      attributes: ['tags']
    });
    const typesSet = new Set();
    rooms.forEach(room => {
      if (Array.isArray(room.tags)) {
        room.tags.forEach(tag => typesSet.add(tag));
      }
    });
    res.status(200).json({
      error: false,
      data: Array.from(typesSet),
      message: 'Tipos de habitaci√≥n obtenidos correctamente'
    });
  } catch (error) {
    next(error);
  }
};
// Obtener una habitaci√≥n por ID
const getRoomById = async (req, res, next) => {
  try {
    const roomNumber = req.params.roomNumber || req.query.roomNumber;

    if (!roomNumber) {
      return res.status(400).json({
        error: true,
        message: "El n√∫mero de habitaci√≥n es requerido",
      });
    }

    const room = await Room.findByPk(roomNumber, {
      include: [
        {
          model: BasicInventory,
          as: 'BasicInventories',
          attributes: [
            "id", "name", "description", "inventoryType", 
            "currentStock", "cleanStock", "dirtyStock", 
            "minStock", "minCleanStock", "category"
          ],
          through: { 
            attributes: ["quantity", "isRequired", "priority"],
            as: 'RoomBasics'
          },
        },
        {
          model: Service,
          attributes: ["name"],
          through: { attributes: [] },
        },
        {
          model: Booking,
          where: { status: { [Op.in]: ['checked-in', 'confirmed'] } },
          required: false,
          attributes: ['bookingId', 'status', 'checkIn', 'checkOut'],
          include: [
            {
              model: BookingInventoryUsage,
              as: 'inventoryUsages',
              include: [
                {
                  model: BasicInventory,
                  as: 'inventory',
                  attributes: ['name', 'inventoryType']
                }
              ]
            }
          ]
        }
      ],
    });

    if (!room) {
      return res.status(404).json({
        error: true,
        message: "Habitaci√≥n no encontrada",
      });
    }

    // ‚≠ê CALCULAR DISPONIBILIDAD DE INVENTARIO
    const roomData = room.toJSON();
    let canCheckIn = true;
    const inventoryChecklist = [];

    if (roomData.BasicInventories) {
      roomData.BasicInventories.forEach(item => {
        const requiredQty = item.RoomBasics.quantity;
        let availableQty = 0;
        let status = 'available';

        if (item.inventoryType === 'reusable') {
          availableQty = item.cleanStock;
          if (availableQty < requiredQty) {
            status = item.RoomBasics.isRequired ? 'insufficient' : 'warning';
            if (item.RoomBasics.isRequired) canCheckIn = false;
          }
        } else {
          availableQty = item.currentStock;
          if (availableQty < requiredQty) {
            status = item.RoomBasics.isRequired ? 'insufficient' : 'warning';
            if (item.RoomBasics.isRequired) canCheckIn = false;
          }
        }

        inventoryChecklist.push({
          id: item.id,
          name: item.name,
          category: item.category,
          type: item.inventoryType,
          required: requiredQty,
          available: availableQty,
          isRequired: item.RoomBasics.isRequired,
          priority: item.RoomBasics.priority,
          status
        });
      });
    }

    res.status(200).json({
      error: false,
      data: {
        ...roomData,
        canCheckIn,
        inventoryChecklist,
        currentBookings: roomData.Bookings || []
      },
      message: "Habitaci√≥n obtenida correctamente",
    });
  } catch (error) {
    next(error);
  }
};

// Revisar disponibilidad
const checkAvailability = async (req, res, next) => {
  try {
    const { dates } = req.params;
    const [startDate, endDate] = dates.split(',');
    const availableRooms = await Room.findAll({
      where: { available: true }
    });
    res.status(200).json({
      error: false,
      data: availableRooms,
      message: 'Habitaciones disponibles obtenidas correctamente'
    });
  } catch (error) {
    next(error);
  }
};



const createRoom = async (req, res, next) => {
  try {
    console.log('üì• Datos recibidos en createRoom:', JSON.stringify(req.body, null, 2));
    
    const {
      roomNumber,
      priceSingle,
      priceDouble,
      priceMultiple,
      pricePerExtraGuest,
      description,
      image_url,
      maxGuests,
      services,
      type,
      basicInventories,
      isPromo,
      promotionPrice
    } = req.body;

    // Validaciones b√°sicas
    if (!roomNumber || !priceSingle || !priceDouble || !priceMultiple) {
      return res.status(400).json({
        error: true,
        message: "Campos requeridos faltantes"
      });
    }

    // Verificar que no exista la habitaci√≥n
    const existingRoom = await Room.findByPk(roomNumber);
    if (existingRoom) {
      return res.status(400).json({
        error: true,
        message: "Ya existe una habitaci√≥n con este n√∫mero"
      });
    }

    // Crear la habitaci√≥n
    const newRoom = await Room.create({
      roomNumber,
      priceSingle,
      priceDouble,
      priceMultiple,
      pricePerExtraGuest: pricePerExtraGuest || 0,
      description,
      image_url,
      maxGuests,
      type,
      isPromo: isPromo || false,
      promotionPrice: promotionPrice || null
    });

    console.log('‚úÖ Habitaci√≥n creada:', newRoom.roomNumber);

    // ‚≠ê ASOCIAR SERVICIOS
    if (services && services.length > 0) {
      console.log('üîß Buscando servicios por nombre:', services);
      
      const serviceInstances = await Service.findAll({
        where: {
          name: services,
        },
      });

      console.log('üîß Servicios encontrados:', serviceInstances.length);
      
      if (serviceInstances.length > 0) {
        await newRoom.setServices(serviceInstances);
        console.log('‚úÖ Servicios asociados correctamente');
      }
    }

    // ‚≠ê ASOCIAR INVENTARIO B√ÅSICO - CORREGIDO
    if (basicInventories && basicInventories.length > 0) {
      console.log('üîß Procesando basicInventories:', basicInventories);
      
      for (const inventoryConfig of basicInventories) {
        const { id, quantity, isRequired = true, priority = 3 } = inventoryConfig;
        
        console.log('üîç Buscando inventario con id:', id);
        
        // ‚≠ê BUSCAR EL ITEM - El 'id' que llega es realmente itemId en la base de datos
        const inventory = await BasicInventory.findOne({
          where: { id: id } // ‚≠ê Ahora deber√≠a funcionar porque enviamos itemId como id
        });
        
        if (!inventory) {
          console.log('‚ùå Item de inventario no encontrado:', id);
          console.log('üîç Disponibles en BD:', await BasicInventory.findAll({
            attributes: ['id', 'name'],
            limit: 5
          }));
          continue; // Continuar con los dem√°s items
        }

        console.log('‚úÖ Item encontrado:', inventory.name);

        // Crear la relaci√≥n en RoomBasics
        const roomBasic = await RoomBasics.create({
          roomNumber: newRoom.roomNumber,
          basicId: inventory.id,
          quantity,
          isRequired,
          priority
        });
        
        console.log('‚úÖ RoomBasic creado:', roomBasic.toJSON());
      }
    }

    // Obtener la habitaci√≥n con todas las relaciones
  const roomWithDetails = await Room.findByPk(newRoom.roomNumber, {
  include: [
    {
      model: Service,
      as: 'Services', // ‚≠ê AGREGAR ESTA L√çNEA SI NO EST√Å
      attributes: ['serviceId', 'name', 'category'],
      through: { attributes: [] },
    },
    {
      model: BasicInventory,
      as: 'BasicInventories', // ‚≠ê ASEGURAR QUE EST√â
      attributes: ['id', 'name', 'category', 'currentStock'],
      through: { 
        attributes: ['quantity', 'isRequired', 'priority'],
        as: 'RoomBasics'
      },
    },
  ],
});

    console.log('‚úÖ Habitaci√≥n creada exitosamente con detalles');

    res.status(201).json({
      error: false,
      data: roomWithDetails,
      message: "Habitaci√≥n creada correctamente",
    });
  } catch (error) {
    console.error('‚ùå Error completo en createRoom:', error);
    next(error);
  }
};

// Actualizar una habitaci√≥n
const updateRoom = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const { services, basicInventories, ...roomData } = req.body;

    const room = await Room.findByPk(roomNumber);
    if (!room) {
      return res.status(404).json({
        error: true,
        message: "Habitaci√≥n no encontrada",
      });
    }

    // Actualizar los datos de la habitaci√≥n
    const updatedRoom = await room.update(roomData);

    // Actualizar las asociaciones con servicios
    if (services && services.length > 0) {
      const serviceInstances = await Service.findAll({
        where: {
          name: services,
        },
      });
      await room.setServices(serviceInstances);
    }

    // ‚≠ê NUEVA L√ìGICA: Actualizar BasicInventories con configuraci√≥n
    if (basicInventories && basicInventories.length > 0) {
      // Eliminar configuraciones actuales
      await RoomBasics.destroy({
        where: { roomNumber }
      });

      // Crear nuevas configuraciones
      for (const inventoryConfig of basicInventories) {
        const { id, quantity, isRequired = true, priority = 3 } = inventoryConfig;
        
        await RoomBasics.create({
          roomNumber,
          basicId: id,
          quantity,
          isRequired,
          priority
        });
      }
    }

    const roomWithDetails = await Room.findByPk(updatedRoom.roomNumber, {
      include: [
        {
          model: Service,
          attributes: ["name"],
          through: { attributes: [] },
        },
        {
          model: BasicInventory,
          as: 'BasicInventories',
          attributes: ["id", "name", "inventoryType", "currentStock", "cleanStock"],
          through: { 
            attributes: ["quantity", "isRequired", "priority"],
            as: 'RoomBasics'
          },
        },
      ],
    });

    res.status(200).json({
      error: false,
      data: roomWithDetails,
      message: "Habitaci√≥n actualizada correctamente",
    });
  } catch (error) {
    next(error);
  }
};

// Eliminar habitaci√≥n
const deleteRoom = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const room = await Room.findOne({ where: { roomNumber: parseInt(roomNumber, 10) } });
    if (!room) {
      return res.status(404).json({
        error: true,
        message: 'Habitaci√≥n no encontrada'
      });
    }

    await room.setServices([]);
    await room.destroy();
    res.status(200).json({
      error: false,
      message: 'Habitaci√≥n eliminada correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Actualizar el estado de la habitaci√≥n
const updateRoomStatus = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const { status } = req.body;
    const room = await Room.findByPk(roomNumber);
    if (!room) {
      return res.status(404).json({
        error: true,
        message: 'Habitaci√≥n no encontrada'
      });
    }
    const validStatuses = ["Limpia", "Ocupada", "Mantenimiento", "Reservada"];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        error: true,
        message: 'Estado inv√°lido'
      });
    }
    const updatedRoom = await room.update({ status });
    res.status(200).json({
      error: false,
      data: updatedRoom,
      message: 'Estado de la habitaci√≥n actualizado correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Obtener amenities de una habitaci√≥n
const getRoomAmenities = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const room = await Room.findByPk(roomNumber);
    if (!room) {
      return res.status(404).json({
        error: true,
        message: 'Habitaci√≥n no encontrada'
      });
    }
    res.status(200).json({
      error: false,
      data: room.tags,
      message: 'Amenities obtenidos correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Actualizar amenities de una habitaci√≥n
const updateRoomAmenities = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const { amenities } = req.body;
    const room = await Room.findByPk(roomNumber);
    if (!room) {
      return res.status(404).json({
        error: true,
        message: 'Habitaci√≥n no encontrada'
      });
    }
    const updatedRoom = await room.update({ tags: amenities });
    res.status(200).json({
      error: false,
      data: updatedRoom,
      message: 'Amenities actualizados correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Obtener servicios de una habitaci√≥n
const getRoomServices = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const room = await Room.findByPk(roomNumber);
    if (!room) {
      return res.status(404).json({
        error: true,
        message: 'Habitaci√≥n no encontrada'
      });
    }
    res.status(200).json({
      error: false,
      data: room.service,
      message: 'Servicios obtenidos correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Actualizar servicios de una habitaci√≥n
const updateRoomServices = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const { services } = req.body;
    const room = await Room.findByPk(roomNumber);
    if (!room) {
      return res.status(404).json({
        error: true,
        message: 'Habitaci√≥n no encontrada'
      });
    }
    const updatedRoom = await room.update({ service: services });
    res.status(200).json({
      error: false,
      data: updatedRoom,
      message: 'Servicios actualizados correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Reporte de ocupaci√≥n
const getOccupancyReport = async (req, res, next) => {
  try {
    const totalRooms = await Room.count();
    const occupiedRooms = await Room.count({ where: { status: 'Ocupada' } });
    const occupancyRate = totalRooms ? ((occupiedRooms / totalRooms) * 100).toFixed(2) : '0.00';
    res.status(200).json({
      error: false,
      data: { totalRooms, occupiedRooms, occupancyRate: `${occupancyRate}%` },
      message: 'Reporte de ocupaci√≥n obtenido correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Reporte de ingresos por tipo de habitaci√≥n
const getRevenueByRoomType = async (req, res, next) => {
  try {
    const revenue = [
      { roomType: 'Suite', totalRevenue: 10000 },
      { roomType: 'Doble', totalRevenue: 8000 },
      { roomType: 'Individual', totalRevenue: 5000 }
    ];
    res.status(200).json({
      error: false,
      data: revenue,
      message: 'Reporte de ingresos por tipo de habitaci√≥n obtenido correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Obtener promociones activas
const getActivePromotions = async (req, res, next) => {
  try {
    const promotions = await Room.findAll({
      where: {
        isPromo: true,
        available: true
      },
      include: [
        {
          model: Service,
          attributes: ['name'],
          through: { attributes: [] }
        }
      ]
    });
    res.status(200).json({
      error: false,
      data: promotions,
      message: 'Promociones activas obtenidas correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Obtener ofertas especiales
const getSpecialOffers = async (req, res, next) => {
  try {
    const specialOffers = await Room.findAll({
      where: {
        isPromo: true,
        promotionPrice: {
          [Op.ne]: null
        },
        available: true
      },
      include: [
        {
          model: Service,
          attributes: ['name'],
          through: { attributes: [] }
        }
      ]
    });
    res.status(200).json({
      error: false,
      data: specialOffers,
      message: 'Ofertas especiales obtenidas correctamente'
    });
  } catch (error) {
    next(error);
  }
};

// Obtener estado de preparaci√≥n de la habitaci√≥n
const getRoomPreparationStatus = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const room = await Room.findOne({
      where: { roomNumber },
      include: [
        { model: Service, attributes: ['name'] },
        { model: RoomCheckIn, as: 'preparation' },
        {
          model: BasicInventory,
          attributes: ['id', 'name'],
          through: { attributes: ['quantity'] },
        },
      ]
    });

    if (!room) {
      return res.status(404).json({ 
        error: true, 
        message: 'Habitaci√≥n no encontrada' 
      });
    }

    res.json({
      error: false,
      data: {
        roomNumber: room.roomNumber,
        status: room.status,
        services: room.Services,
        lastPreparation: room.preparation || null,
        basics: room.BasicInventories
      }
    });
  } catch (error) {
    next(error);
  }
};

// Obtener b√°sicos de la habitaci√≥n
const getRoomBasics = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const room = await Room.findByPk(roomNumber, {
      include: [
        {
          model: BasicInventory,
          as: 'BasicInventories',
          attributes: [
            'id', 'name', 'description', 'inventoryType', 
            'currentStock', 'cleanStock', 'dirtyStock',
            'minStock', 'minCleanStock', 'category'
          ],
          through: { 
            attributes: ['quantity', 'isRequired', 'priority'],
            as: 'RoomBasics'
          }
        }
      ]
    });
    
    if (!room) {
      return res.status(404).json({ 
        error: true, 
        message: 'Habitaci√≥n no encontrada' 
      });
    }
    
    // ‚≠ê PROCESAR INVENTARIO CON ESTADO DETALLADO
    const basics = room.BasicInventories.map(basic => {
      const requiredQty = basic.RoomBasics.quantity;
      let availableQty = 0;
      let stockStatus = 'ok';
      let stockInfo = {};

      if (basic.inventoryType === 'reusable') {
        availableQty = basic.cleanStock;
        stockInfo = {
          cleanStock: basic.cleanStock,
          dirtyStock: basic.dirtyStock,
          totalStock: basic.cleanStock + basic.dirtyStock,
          minCleanStock: basic.minCleanStock
        };
        
        if (availableQty < requiredQty) {
          stockStatus = 'insufficient';
        } else if (availableQty <= basic.minCleanStock) {
          stockStatus = 'low';
        }
      } else {
        availableQty = basic.currentStock;
        stockInfo = {
          currentStock: basic.currentStock,
          minStock: basic.minStock
        };
        
        if (availableQty < requiredQty) {
          stockStatus = 'insufficient';
        } else if (availableQty <= basic.minStock) {
          stockStatus = 'low';
        }
      }

      return {
        id: basic.id,
        name: basic.name,
        description: basic.description,
        category: basic.category,
        inventoryType: basic.inventoryType,
        required: requiredQty,
        available: availableQty,
        isRequired: basic.RoomBasics.isRequired,
        priority: basic.RoomBasics.priority,
        stockStatus,
        stockInfo,
        canAssign: availableQty >= requiredQty
      };
    });
    
    // ‚≠ê CALCULAR RESUMEN GENERAL
    const summary = {
      totalItems: basics.length,
      readyItems: basics.filter(b => b.canAssign).length,
      insufficientItems: basics.filter(b => !b.canAssign && b.isRequired).length,
      warningItems: basics.filter(b => b.stockStatus === 'low').length,
      canProceedCheckIn: basics.filter(b => b.isRequired && !b.canAssign).length === 0
    };
    
    res.json({
      error: false,
      data: {
        roomNumber,
        basics,
        summary
      },
      message: 'Inventario b√°sico de la habitaci√≥n recuperado exitosamente'
    });
  } catch (error) {
    next(error);
  }
};


const checkInventoryAvailability = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const { bookingId } = req.query;

    const room = await Room.findByPk(roomNumber, {
      include: [
        {
          model: BasicInventory,
          as: 'BasicInventories',
          attributes: ['id', 'name', 'inventoryType', 'currentStock', 'cleanStock'],
          through: { 
            attributes: ['quantity', 'isRequired'],
            as: 'RoomBasics'
          }
        }
      ]
    });

    if (!room) {
      return res.status(404).json({
        error: true,
        message: 'Habitaci√≥n no encontrada'
      });
    }

    // Verificar si ya tiene inventario asignado
    let existingAssignment = null;
    if (bookingId) {
      existingAssignment = await BookingInventoryUsage.findOne({
        where: { bookingId }
      });
    }

    const availabilityCheck = {
      roomNumber,
      canProceedCheckIn: true,
      hasExistingAssignment: !!existingAssignment,
      items: [],
      issues: []
    };

    for (const item of room.BasicInventories) {
      const requiredQty = item.RoomBasics.quantity;
      const availableQty = item.inventoryType === 'reusable' ? item.cleanStock : item.currentStock;
      const isAvailable = availableQty >= requiredQty;

      if (!isAvailable && item.RoomBasics.isRequired) {
        availabilityCheck.canProceedCheckIn = false;
        availabilityCheck.issues.push({
          item: item.name,
          type: item.inventoryType,
          required: requiredQty,
          available: availableQty,
          severity: 'critical'
        });
      }

      availabilityCheck.items.push({
        id: item.id,
        name: item.name,
        type: item.inventoryType,
        required: requiredQty,
        available: availableQty,
        isRequired: item.RoomBasics.isRequired,
        status: isAvailable ? 'ok' : (item.RoomBasics.isRequired ? 'critical' : 'warning')
      });
    }

    res.json({
      error: false,
      data: availabilityCheck,
      message: 'Verificaci√≥n de disponibilidad de inventario completada'
    });
  } catch (error) {
    next(error);
  }
};
// ‚≠ê NUEVO: Calcular precio de habitaci√≥n
const calculateRoomPrice = async (req, res, next) => {
  try {
    const { roomNumber, guestCount, checkIn, checkOut, promoCode } = req.body;

    // Validaciones de entrada
    if (!roomNumber || !guestCount || !checkIn || !checkOut) {
      return res.status(400).json({
        error: true,
        message: 'Faltan par√°metros requeridos: roomNumber, guestCount, checkIn, checkOut'
      });
    }

    if (guestCount <= 0) {
      return res.status(400).json({
        error: true,
        message: 'La cantidad de hu√©spedes debe ser mayor a 0'
      });
    }

    // Buscar la habitaci√≥n
    const room = await Room.findByPk(roomNumber);
    
    if (!room) {
      return res.status(404).json({
        error: true,
        message: 'Habitaci√≥n no encontrada'
      });
    }

    if (!room.isActive) {
      return res.status(400).json({
        error: true,
        message: 'Habitaci√≥n no disponible'
      });
    }

    // Calcular noches
    const checkInDate = new Date(checkIn);
    const checkOutDate = new Date(checkOut);
    const nights = Math.ceil((checkOutDate - checkInDate) / (1000 * 60 * 60 * 24));
    
    if (nights < 1) {
      return res.status(400).json({
        error: true,
        message: 'La fecha de salida debe ser posterior a la fecha de entrada'
      });
    }

    // Aplicar c√≥digo promocional si existe
    if (promoCode && room.promotionPrice) {
      room.isPromo = true;
    }

    // Calcular precio usando el m√©todo del modelo (si existe)
    let priceCalculation;
    if (typeof room.calculatePrice === 'function') {
      try {
        priceCalculation = room.calculatePrice(guestCount, nights);
      } catch (calculationError) {
        return res.status(400).json({
          error: true,
          message: calculationError.message
        });
      }
    } else {
      // ‚≠ê FALLBACK: C√°lculo manual si no existe el m√©todo
      let pricePerNight;
      
      if (room.isPromo && room.promotionPrice) {
        pricePerNight = parseFloat(room.promotionPrice);
      } else {
        if (guestCount === 1) {
          pricePerNight = parseFloat(room.priceSingle || room.price || 0);
        } else if (guestCount === 2) {
          pricePerNight = parseFloat(room.priceDouble || room.price || 0);
        } else {
          pricePerNight = parseFloat(room.priceMultiple || room.price || 0);
        }
      }

      const totalAmount = pricePerNight * nights;
      
      priceCalculation = {
        pricePerNight,
        totalAmount,
        isPromotion: room.isPromo && room.promotionPrice ? true : false,
        breakdown: {
          basePrice: pricePerNight,
          nights,
          guestCount,
          extraGuestCharges: 0
        }
      };
    }

    // Respuesta exitosa
    res.json({
      error: false,
      message: 'Precio calculado exitosamente',
      data: {
        roomNumber: room.roomNumber,
        roomType: room.type,
        guestCount,
        nights,
        checkIn: checkInDate.toISOString(),
        checkOut: checkOutDate.toISOString(),
        ...priceCalculation,
        roomDetails: {
          description: room.description,
          maxGuests: room.maxGuests,
          available: room.available,
          status: room.status
        }
      }
    });

  } catch (error) {
    next(error);
  }
};

const getRoomInventoryHistory = async (req, res, next) => {
  try {
    const { roomNumber } = req.params;
    const { startDate, endDate, limit = 20 } = req.query;

    const whereClause = {};
    if (startDate && endDate) {
      whereClause.assignedAt = {
        [Op.between]: [new Date(startDate), new Date(endDate)]
      };
    }

    const usageHistory = await BookingInventoryUsage.findAll({
      where: whereClause,
      include: [
        {
          model: Booking,
          as: 'booking',
          where: { roomNumber },
          attributes: ['bookingId', 'checkIn', 'checkOut', 'status']
        },
        {
          model: BasicInventory,
          as: 'inventory',
          attributes: ['name', 'inventoryType', 'category']
        }
      ],
      order: [['assignedAt', 'DESC']],
      limit: parseInt(limit)
    });

    // Procesar estad√≠sticas
    const stats = {
      totalUsages: usageHistory.length,
      itemsSummary: {},
      averageUsageByType: {}
    };

    usageHistory.forEach(usage => {
      const itemName = usage.inventory.name;
      const itemType = usage.inventory.inventoryType;

      if (!stats.itemsSummary[itemName]) {
        stats.itemsSummary[itemName] = {
          name: itemName,
          type: itemType,
          totalAssigned: 0,
          totalConsumed: 0,
          totalReturned: 0,
          usageCount: 0
        };
      }

      stats.itemsSummary[itemName].totalAssigned += usage.quantityAssigned;
      stats.itemsSummary[itemName].totalConsumed += usage.quantityConsumed;
      stats.itemsSummary[itemName].totalReturned += usage.quantityReturned;
      stats.itemsSummary[itemName].usageCount += 1;

      if (!stats.averageUsageByType[itemType]) {
        stats.averageUsageByType[itemType] = { total: 0, count: 0 };
      }
      stats.averageUsageByType[itemType].total += usage.quantityAssigned;
      stats.averageUsageByType[itemType].count += 1;
    });

    // Calcular promedios
    Object.keys(stats.averageUsageByType).forEach(type => {
      const data = stats.averageUsageByType[type];
      stats.averageUsageByType[type] = data.count > 0 ? (data.total / data.count).toFixed(2) : 0;
    });

    res.json({
      error: false,
      data: {
        roomNumber,
        period: { startDate, endDate },
        usageHistory,
        statistics: {
          ...stats,
          itemsSummary: Object.values(stats.itemsSummary)
        }
      },
      message: 'Historial de inventario de habitaci√≥n obtenido exitosamente'
    });
  } catch (error) {
    next(error);
  }
};

// ‚≠ê NUEVO: Calcular precios de m√∫ltiples habitaciones
const calculateMultipleRoomPrices = async (req, res, next) => {
  try {
    const { roomNumbers, guestCount, checkIn, checkOut } = req.body;

    if (!Array.isArray(roomNumbers) || roomNumbers.length === 0) {
      return res.status(400).json({
        error: true,
        message: 'Debe proporcionar al menos un n√∫mero de habitaci√≥n'
      });
    }

    const rooms = await Room.findAll({
      where: {
        roomNumber: roomNumbers,
        isActive: true
      }
    });

    const checkInDate = new Date(checkIn);
    const checkOutDate = new Date(checkOut);
    const nights = Math.ceil((checkOutDate - checkInDate) / (1000 * 60 * 60 * 24));

    const calculations = rooms.map(room => {
      try {
        let priceCalculation;
        
        if (typeof room.calculatePrice === 'function') {
          priceCalculation = room.calculatePrice(guestCount, nights);
        } else {
          // Fallback calculation
          let pricePerNight;
          
          if (guestCount === 1) {
            pricePerNight = parseFloat(room.priceSingle || room.price || 0);
          } else if (guestCount === 2) {
            pricePerNight = parseFloat(room.priceDouble || room.price || 0);
          } else {
            pricePerNight = parseFloat(room.priceMultiple || room.price || 0);
          }

          priceCalculation = {
            pricePerNight,
            totalAmount: pricePerNight * nights,
            isPromotion: false
          };
        }

        return {
          roomNumber: room.roomNumber,
          roomType: room.type,
          maxGuests: room.maxGuests,
          available: room.available,
          ...priceCalculation,
          error: null
        };
      } catch (error) {
        return {
          roomNumber: room.roomNumber,
          error: error.message,
          available: false
        };
      }
    });

    res.json({
      error: false,
      message: 'Precios calculados exitosamente',
      data: {
        guestCount,
        nights,
        checkIn: checkInDate.toISOString(),
        checkOut: checkOutDate.toISOString(),
        rooms: calculations
      }
    });

  } catch (error) {
    next(error);
  }
};

module.exports = {
  getActivePromotions,
  getSpecialOffers,
  getAllRooms,
  getRoomTypes,
  getRoomById,
  checkAvailability,
  createRoom,
  updateRoom,
  deleteRoom,
  updateRoomStatus,
  getRoomAmenities,
  updateRoomAmenities,
  getRoomServices,
  updateRoomServices,
  getOccupancyReport,
  getRevenueByRoomType,
  getRoomPreparationStatus,
  getRoomBasics,
  calculateRoomPrice,
  calculateMultipleRoomPrices,
   checkInventoryAvailability, // ‚≠ê NUEVO
  getRoomInventoryHistory, // ‚≠ê NUEVO
};